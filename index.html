<!doctype html>
<html lang="zh-TW">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Pool Poker</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            background: #071024;
            color: #e6eef8;
            font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, Arial;
        }

        .card {
            width: 54px;
            height: 74px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            box-shadow: 0 6px 16px rgba(0, 0, 0, .6);
            transition: transform 0.3s;
        }

        /* å¡èƒŒæ¨£å¼: ç¶“å…¸ç´…è‰²è±å½¢æ ¼ç´‹ */
        .card-back {
            background-color: #c93535;
            background-image:
                repeating-linear-gradient(45deg,
                    transparent, transparent 7px,
                    rgba(255, 255, 255, 0.4) 7px,
                    rgba(255, 255, 255, 0.4) 8px
                ),
                repeating-linear-gradient(-45deg,
                    transparent, transparent 7px,
                    rgba(255, 255, 255, 0.4) 7px,
                    rgba(255, 255, 255, 0.4) 8px);

            background-size: 10px 10px;
            border: 2px solid rgba(255, 255, 255, .1);
            color: transparent;
        }

        .card-face {
            background: white;
            color: #071024;
            border: 2px solid rgba(2, 6, 23, .06);
        }

        /* æ¶ˆé™¤æ¨™è¨˜æ¨£å¼ */
        .marked {
            position: relative;
            outline: none;
            transform: none;
            filter: brightness(0.95);
        }

        .my-card.marked {
            filter: none;
        }

        /* åŠƒç·šæ•ˆæœ (åƒ…é™è‡ªå·±çš„ç‰Œ) */
        .my-card.marked::after {
            content: "";
            position: absolute;
            inset: 0;
            border-radius: 8px;
            pointer-events: none;

            background: linear-gradient(to top right,
                transparent calc(50% - 2.5px),
                rgba(56, 189, 248, 0.9) calc(50% - 0.7px),
                rgba(56, 189, 248, 0.9) calc(50% + 0.7px),
                transparent calc(50% + 2.5px));
        }

        .small {
            font-size: .85rem;
            color: #cfe8ff;
        }

        .suit-red {
            color: #dc2626;
        }

        .suit-black {
            color: #111827;
        }

        /* çŠ¯è¦æŒ‰éˆ• */
        .foul-btn {
            background: #ef4444;
            color: white;
            padding: 6px 8px;
            border-radius: 6px;
            font-weight: 600;
            cursor: pointer;
            border: none;
        }

        .foul-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
            background: #7f1d1d;
        }
        
        /* æ–°å¢: æ’­æ”¾è²éŸ³æŒ‰éˆ•æ¨£å¼ (åŸºç¤) */
        .speaker-btn {
            padding: 6px 8px;
            border-radius: 6px;
            font-weight: 600;
            cursor: pointer;
            border: none;
            transition: background 0.2s;
            font-size: 0.85rem;
        }

        /* æ’­æ”¾ç‹€æ…‹ (Play) */
        .speaker-btn.play {
            background: #007bff; /* è—è‰² */
            color: white;
        }

        .speaker-btn.play:hover {
            background: #0056b3;
        }

        /* åœæ­¢ç‹€æ…‹ (Stop) */
        .speaker-btn.stop {
            background: #dc3545; /* ç´…è‰² */
            color: white;
        }

        .speaker-btn.stop:hover {
            background: #c82333;
        }

        /* ã€æ–°å¢æ¨£å¼ã€‘: é–å®šç‹€æ…‹çš„ speaker-btn (ç”¨æ–¼éè‡ªå·±çš„ç‰Œçµ„) */
        .speaker-btn:disabled {
            background: #475569; /* ç°è—è‰² */
            color: #e2e8f0;
            cursor: not-allowed;
            opacity: 0.6;
            transform: none;
            box-shadow: none;
        }

        .player-header {
            display: flex;
            gap: 8px;
            align-items: center;
            justify-content: space-between;
        }

        /* çƒæŒ‰éˆ•æ¨£å¼ */
        .ball-btn {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            font-weight: 700;
            cursor: pointer;
            border: 2px solid transparent;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            margin: 4px;
            user-select: none;
            transition: transform 160ms ease, box-shadow 160ms ease, border-color 160ms ease, filter 160ms ease;
            box-shadow: 0 6px 12px rgba(2, 6, 23, 0.6), inset 0 -6px 10px rgba(255, 255, 255, 0.03);
            color: #071024;
            font-size: 14px;
            position: relative;
        }

        .ball-btn:hover {
            transform: translateY(-3px) scale(1.03);
            filter: brightness(1.06);
        }

        .ball-btn:active {
            transform: translateY(0) scale(0.98);
        }

        .ball-btn.selected {
            border-color: #55CCFF;
            box-shadow: 0 8px 18px rgba(85, 204, 255, 0.2), 0 0 8px rgba(85, 204, 255, 0.3);
            transform: scale(1.12);
            filter: brightness(1.08);
        }

        .ball-yellow {
            --ball-color-solid: #FFA600;
            background: linear-gradient(180deg, #ffc65b, #ffa600);
        }

        .ball-blue {
            --ball-color-solid: #2337f0;
            background: linear-gradient(180deg, #3462c5, #0011aa);
            color: white;
        }

        .ball-red {
            --ball-color-solid: #CC0000;
            background: linear-gradient(180deg, #e64a4a, #cc0000);
            color: white;
        }

        .ball-purple {
            --ball-color-solid: #5733bb;
            background: linear-gradient(180deg, #615ac4, #5733bb);
            color: white;
        }

        .ball-orange {
            --ball-color-solid: #dd7d00;
            background: linear-gradient(180deg, #fcae61, #dd7d00);
        }

        .ball-green {
            --ball-color-solid: #129900;
            background: linear-gradient(180deg, #64b84f, #138304);
            color: white;
        }

        .ball-maroon {
            --ball-color-solid: #663333;
            background: linear-gradient(180deg, #9e5f5f, #663633);
            color: white;
        }

        .ball-black {
            --ball-color-solid: #000000;
            background: radial-gradient(circle at 30% 30%, #a39595, #000000 60%);
            color: white;
            border-color: rgba(255, 255, 255, 0.06);
        }

        .ball-stripe {
            background: linear-gradient(to bottom,
                white 0%,
                white 20%,
                var(--ball-color-solid) 20%,
                var(--ball-color-solid) 80%,
                white 80%,
                white 100%);
            color: #071024;
            font-weight: 700;
            overflow: hidden;
        }

        /* ===== è·‘é¦¬ç‡ˆæ¨£å¼ ===== */
        #marqueeContainer {
            overflow: hidden;
            white-space: nowrap;
            background-color: #1e293b;
            padding: 6px 0;
            border-radius: 8px;
            margin-bottom: 1rem;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.4);
        }

        #marqueeText {
            display: inline-block;
            color: #fde047;
            /* é»ƒè‰²æ–‡å­— */
            font-weight: 700;
            padding-left: 100%;
            /* å¾å³é‚Šé–‹å§‹ç§»å‹• */
            animation: marquee 15s linear infinite;
            /* 15ç§’ä¸€å€‹å¾ªç’° */
        }

        @keyframes marquee {
            0% {
                transform: translate(0, 0);
            }

            100% {
                transform: translate(-100%, 0);
            }
        }

        @media (max-width:640px) {
            .ball-btn {
                width: 34px;
                height: 34px;
                font-size: 13px;
                margin: 3px;
            }
        }
    </style>
</head>

<body>
    <div class="max-w-5xl mx-auto p-6">
        <div id="marqueeContainer">
            <div id="marqueeText">æ­¡è¿ä½¿ç”¨ ~ Card Pool Challengeï¼</div>
        </div>

        <div id="status" class="mb-4 text-sm small">åˆå§‹åŒ–ä¸­â€¦</div>

        <div id="joinPanel" class="mb-6 grid grid-cols-1 sm:grid-cols-3 gap-3">
            <div class="col-span-2">
                <label class="small">æš±ç¨±</label>
                <input id="nickname" class="w-full p-2 rounded bg-slate-800 border border-slate-700"
                    placeholder="è¼¸å…¥æš±ç¨±" />
            </div>
            <div>
                <button id="btnJoin" class="w-full py-2 rounded bg-emerald-600 hover:bg-emerald-500">åŠ å…¥æˆ¿é–“</button>
            </div>
        </div>

        <div id="roomPanel" class="mb-6 p-4 rounded bg-slate-900 border border-slate-700 hidden">
            <div class="flex items-center justify-between mb-3">
                <div>
                    <div class="text-xs small">æˆ¿é–“ ID</div>
                    <div class="font-mono">main-room</div>
                </div>
                <div>
                    <div class="text-xs small">æˆ¿ä¸»</div>
                    <div id="roomOwner" class="font-bold">â€”</div>
                </div>
                <div>
                    <div class="text-xs small">äººæ•¸</div>
                    <div id="roomCount">0 / 5</div>
                </div>
                <div>
                    <div class="text-xs small">æˆ‘çš„æš±ç¨±</div>
                    <div id="myNick" class="font-mono">â€”</div>
                </div>
            </div>

            <div class="flex gap-2 items-center mb-4">
                <button id="btnStart" class="px-3 py-2 rounded bg-yellow-600 hover:bg-yellow-500 hidden">ç™¼ç‰Œ</button>
                <button id="btnRestart" class="px-3 py-2 rounded bg-slate-700 hover:bg-slate-600 hidden">é‡é–‹</button>
                <button id="btnLeave" class="px-3 py-2 rounded bg-red-600 hover:bg-red-500 ml-auto">é€€å‡ºæˆ¿é–“</button>
                <div id="notice" class="ml-4 small text-slate-300"></div>
            </div>

            <div id="ballButtons" class="mb-4"></div>
            <div id="playersArea" class="grid grid-cols-1 md:grid-cols-2 gap-4"></div>
        </div>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, onSnapshot, setDoc, updateDoc, getDoc, deleteDoc, serverTimestamp, arrayUnion, arrayRemove, deleteField, runTransaction } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        const EXTERNAL_FIREBASE_CONFIG = {
            apiKey: "AIzaSyCk54DEp6rzvpfQBBNW_iJByZ3boyHEPF0",
            authDomain: "poolpokergame-b88ed.firebaseapp.com",
            projectId: "poolpokergame-b88ed",
            storageBucket: "poolpokergame-b88ed.firebasestorage.app",
            messagingSenderId: "574863840102",
            appId: "1:574863840102:web:14368aaf84b3640c6eeea7"
        };

        const APP_ID = EXTERNAL_FIREBASE_CONFIG.projectId;
        const ROOM_PATH = `artifacts/${APP_ID}/public/data/pool_poker_rooms/main_room`;
        const CARDS_PER_PLAYER = 8;
        const MAX_PLAYERS = 5;
        const MAX_EXTRA = 6;

        const statusEl = document.getElementById('status');
        const nicknameInput = document.getElementById('nickname');
        const btnJoin = document.getElementById('btnJoin');
        const joinPanel = document.getElementById('joinPanel');
        const roomPanel = document.getElementById('roomPanel');
        const roomOwnerEl = document.getElementById('roomOwner');
        const roomCountEl = document.getElementById('roomCount');
        const playersArea = document.getElementById('playersArea');
        const myNickEl = document.getElementById('myNick');
        const btnStart = document.getElementById('btnStart');
        const btnRestart = document.getElementById('btnRestart');
        const btnLeave = document.getElementById('btnLeave');
        const noticeEl = document.getElementById('notice');
        const ballButtonsEl = document.getElementById('ballButtons');
        const marqueeTextEl = document.getElementById('marqueeText');

        const app = initializeApp(EXTERNAL_FIREBASE_CONFIG);
        const auth = getAuth(app);
        const db = getFirestore(app);
        const roomRef = doc(db, ROOM_PATH);

        let currentUser = null;
        let gameState = null;
        let myNickname = '';

        function setStatus(s) { statusEl.textContent = s; }

        async function doAnonymousAuth() {
            setStatus('ä½¿ç”¨åŒ¿åç™»å…¥ Firebase...');
            try { const cred = await signInAnonymously(auth); console.log('signed in uid=', cred.user.uid); }
            catch (e) { console.log('auth failed', e); setStatus('Auth å¤±æ•—'); }
        }

        onAuthStateChanged(auth, (user) => { currentUser = user; if (user) { setStatus('å·²ç™»å…¥ï¼š' + user.uid); subscribeRoom(); } else { setStatus('æœªç™»å…¥'); } });

        let unsubscribe = null;
        function subscribeRoom() {
            if (unsubscribe) return;
            setStatus('è¨‚é–± main-room...');
            unsubscribe = onSnapshot(roomRef, (snap) => {
                if (!snap.exists()) { gameState = null; renderUI(); setStatus('æˆ¿é–“å°šæœªå»ºç«‹æˆ–å·²è¢«æ¸…ç©º'); return; }
                gameState = snap.data(); renderUI(); setStatus('å·²é€£åˆ°æˆ¿é–“');
            }, (err) => { console.log('snapshot err', err); setStatus('è¨‚é–±å¤±æ•—'); });
        }

        const suits = ['â™£', 'â™¦', 'â™¥', 'â™ '];
        const rankMap = { 1: 'A', 11: 'J', 12: 'Q', 13: 'K' };

        function getCardRank(cardCode) {
            const r = cardCode.slice(1);
            if (r === 'A') return 1;
            if (r === 'J') return 11;
            if (r === 'Q') return 12;
            if (r === 'K') return 13;
            return parseInt(r);
        }

        function buildDeck() { const deck = []; for (let r = 1; r <= 13; r++) { for (let s = 0; s < 4; s++) { const rank = rankMap[r] || String(r); deck.push({ suit: suits[s], rank, code: `${suits[s]}${rank}` }); } } return deck; }
        function shuffle(arr) { for (let i = arr.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1));[arr[i], arr[j]] = [arr[j], arr[i]]; } return arr; }

        function calculateUnmarkedCards(cards, revealedNumbers) {
            if (!cards || cards.length === 0) return 0;
            if (!revealedNumbers || revealedNumbers.length === 0) return cards.length;
            let unmarkedCount = 0;
            for (const cardCode of cards) {
                const rank = getCardRank(cardCode);
                if (!revealedNumbers.includes(rank)) {
                    unmarkedCount++;
                }
            }
            return unmarkedCount;
        }

        function updateMarquee() {
            if (!gameState || !gameState.gameStarted) {
                marqueeTextEl.textContent = "ğŸ± Welcome to Card Pool Challenge. ç¨ç­‰ç™¼ç‰Œ...éŠæˆ²å³å°‡é–‹å§‹ ~ é ç¥å„ä½éƒ½èƒ½æŠ½å‰¯å¥½ç‰Œï¼";
                return;
            }

            const players = gameState.players || {};
            const revealedNumbers = gameState.revealedNumbers || [];
            const messages = [];

            for (const playerId in players) {
                const player = players[playerId];
                if (player && player.id) {
                    const cards = player.cards || [];
                    const unmarkedCards = calculateUnmarkedCards(cards, revealedNumbers);
                    messages.push(`ã€${player.nickname}ã€‘å‰©é¤˜ç‰Œï¼š${unmarkedCards} å¼µ`);
                }
            }

            if (messages.length > 0) {
                const separator = " ğŸŒŸ ";
                let content = messages.join(separator);
                content = "ğŸ† ç•¶å‰ç‰Œå±€é€²åº¦: " + content + separator + content + separator + content + separator;
                marqueeTextEl.textContent = content;
            } else {
                marqueeTextEl.textContent = "ğŸ± éŠæˆ²å·²é–‹å§‹ï¼Œç­‰å¾…ç©å®¶åŠ å…¥æˆ–ç™¼ç‰Œ...";
            }
        }

        function toggleNumber(n) {
            if (!gameState) return;
            const numbers = Array.isArray(gameState.revealedNumbers) ? [...gameState.revealedNumbers] : [];
            if (numbers.includes(n)) numbers.splice(numbers.indexOf(n), 1);
            else numbers.push(n);
            updateDoc(roomRef, { revealedNumbers: numbers, updatedAt: serverTimestamp() })
                .catch(e => console.log('toggleNumber err', e));
        }

        function renderBallButtons() {
            ballButtonsEl.innerHTML = '';
            for (let n = 1; n <= 13; n++) {
                const btn = document.createElement('button');
                btn.className = 'ball-btn';
                btn.textContent = n;
                if (n === 1 || n === 9) btn.classList.add('ball-yellow');
                else if (n === 2 || n === 10) btn.classList.add('ball-blue');
                else if (n === 3 || n === 11) btn.classList.add('ball-red');
                else if (n === 4 || n === 12) btn.classList.add('ball-purple');
                else if (n === 5 || n === 13) btn.classList.add('ball-orange');
                else if (n === 6) btn.classList.add('ball-green');
                else if (n === 7) btn.classList.add('ball-maroon');
                else if (n === 8) btn.classList.add('ball-black');
                if (n >= 9 && n <= 13) { btn.classList.add('ball-stripe'); }
                if (gameState.revealedNumbers && gameState.revealedNumbers.includes(n)) btn.classList.add('selected');
                btn.onclick = () => { toggleNumber(n); };
                ballButtonsEl.appendChild(btn);
            }
        }

        btnJoin.addEventListener('click', async () => {
            if (!currentUser) { setStatus('å°šæœªç™»å…¥'); return; }
            const nickInput = (nicknameInput.value || '').trim(); if (!nickInput) { setStatus('è«‹å…ˆè¼¸å…¥æš±ç¨±'); return; }
            const isKai = nickInput === 'Kai';
            try {
                const snap = await getDoc(roomRef);
                if (!snap.exists()) {
                    const players = {}; players[currentUser.uid] = { id: currentUser.uid, nickname: isKai ? 'Kai' : nickInput, cards: [] };
                    const docData = { players, gameStarted: false, notice: isKai ? 'æˆ¿ä¸» Kai å·²å»ºç«‹æˆ¿é–“' : 'æˆ¿é–“å·²å»ºç«‹', updatedAt: serverTimestamp(), deck: [], revealedNumbers: [] };
                    if (isKai) docData.creatorId = currentUser.uid;
                    await setDoc(roomRef, docData);
                    myNickname = isKai ? 'Kai' : nickInput; nicknameInput.value = isKai ? '' : nickInput; setStatus(isKai ? 'å·²ä»¥ Kai å»ºç«‹æˆ¿é–“' : 'æˆ¿é–“å»ºç«‹'); return;
                } else {
                    const data = snap.data(); const players = data.players || {};
                    const realCount = Object.values(players).filter(p => p && p.id).length; if (realCount >= MAX_PLAYERS) { setStatus('æˆ¿é–“å·²æ»¿'); return; }
                    if (players[currentUser.uid] && players[currentUser.uid].id) { setStatus('æ‚¨å·²åœ¨æˆ¿é–“ä¸­'); return; }
                    const updateObj = { updatedAt: serverTimestamp() };
                    updateObj[`players.${currentUser.uid}`] = { id: currentUser.uid, nickname: isKai ? 'Kai' : nickInput, cards: [] };
                    if (isKai) { updateObj['creatorId'] = currentUser.uid; updateObj['notice'] = 'Kai å·²æˆç‚ºæˆ¿ä¸»'; myNickname = 'Kai'; nicknameInput.value = ''; } else { myNickname = nickInput; }
                    updateDoc(roomRef, updateObj); setStatus('å·²åŠ å…¥æˆ¿é–“');
                }
            } catch (e) { console.log('join err', e); setStatus('åŠ å…¥å¤±æ•—'); }
        });

        btnLeave.addEventListener('click', async () => { if (!currentUser) return; try { if (gameState.creatorId === currentUser.uid && myNickname === 'Kai') { await deleteDoc(roomRef); setStatus('æˆ¿ä¸»å·²é€€å‡º'); return; } await updateDoc(roomRef, { [`players.${currentUser.uid}`]: deleteField(), updatedAt: serverTimestamp() }); setStatus('å·²é€€å‡ºæˆ¿é–“'); myNickname = ''; stopSpeaking(); } catch (e) { console.log('leave err', e); setStatus('é€€å‡ºå¤±æ•—'); } });

        btnStart.addEventListener('click', async () => {
            if (!currentUser || !gameState) return; if (gameState.creatorId !== currentUser.uid || myNickname !== 'Kai') { setStatus('åªæœ‰ Kai æˆ¿ä¸»å¯ä»¥ç™¼ç‰Œ'); return; }
            try {
                const players = gameState.players || {}; const pids = Object.keys(players).filter(k => players[k] && players[k].id);
                let deckObj = buildDeck().map(c => c.code); shuffle(deckObj);
                const updateObj = { gameStarted: true, notice: 'éŠæˆ²é–‹å§‹ï¼šå·²ç™¼ç‰Œ', updatedAt: serverTimestamp() };
                pids.forEach((pid, idx) => {
                    const start = idx * CARDS_PER_PLAYER;
                    const hand = deckObj.slice(start, start + CARDS_PER_PLAYER);
                    updateObj[`players.${pid}.cards`] = hand;
                });
                updateObj['deck'] = deckObj.slice(pids.length * CARDS_PER_PLAYER);
                updateObj['revealedNumbers'] = [];
                await updateDoc(roomRef, updateObj);
                setStatus('ç™¼ç‰Œå®Œæˆ');
            } catch (e) { console.log('start err', e); setStatus('ç™¼ç‰Œå¤±æ•—'); }
        });

        btnRestart.addEventListener('click', async () => {
            if (!currentUser || !gameState) return; if (gameState.creatorId !== currentUser.uid || myNickname !== 'Kai') { setStatus('åªæœ‰ Kai æˆ¿ä¸»å¯ä»¥é‡é–‹'); return; }
            try {
                const players = gameState.players || {}; const updateObj = { gameStarted: false, notice: 'æˆ¿ä¸»å·²é‡é–‹éŠæˆ²', updatedAt: serverTimestamp(), revealedNumbers: [] };
                Object.keys(players).forEach(pid => { if (players[pid] && players[pid].id) { updateObj[`players.${pid}.cards`] = []; } });
                updateObj['deck'] = [];
                await updateDoc(roomRef, updateObj);
                setStatus('å·²é‡é–‹');
                stopSpeaking(); // é‡é–‹éŠæˆ²æ™‚ï¼Œåœæ­¢èªéŸ³
            } catch (e) { console.log('restart err', e); setStatus('é‡é–‹å¤±æ•—'); }
        });

        async function foulDrawFor(playerId) {
            if (!currentUser) return;
            try {
                await runTransaction(db, async tx => {
                    const snap = await tx.get(roomRef); if (!snap.exists()) throw new Error('æˆ¿é–“ä¸å­˜åœ¨'); const data = snap.data();
                    const deck = Array.isArray(data.deck) ? [...data.deck] : []; const players = data.players || {}; const target = players[playerId];
                    if (!target || !target.id) throw new Error('ç©å®¶ä¸å­˜åœ¨'); const currentCount = Array.isArray(target.cards) ? target.cards.length : 0;
                    if (currentCount >= CARDS_PER_PLAYER + MAX_EXTRA) throw new Error('æ­¤ç©å®¶å·²é”æœ€å¤š 14 å¼µï¼ˆä¸èƒ½å†æŠ½ï¼‰'); if (deck.length === 0) throw new Error('å‰©é¤˜ç‰Œå·²ç¶“æŠ½å®Œ');
                    const drawn = deck.pop(); const newPlayers = { ...players, [playerId]: { ...target, cards: [...(target.cards || []), drawn] } };
                    tx.update(roomRef, { players: newPlayers, deck: deck, updatedAt: serverTimestamp() });
                }); setStatus('çŠ¯è¦æŠ½ç‰ŒæˆåŠŸ');
            } catch (e) { console.log('foul draw err', e); setStatus('çŠ¯è¦æŠ½ç‰Œå¤±æ•—ï¼š' + (e.message || e)); }
        }

        // ====== èªéŸ³æ’­æ”¾æ ¸å¿ƒèˆ‡ç‹€æ…‹ ======

        // å…¨åŸŸç‹€æ…‹ï¼šè¿½è¹¤ç›®å‰æ˜¯å¦æ­£åœ¨æ’­æ”¾ï¼Œä»¥åŠæ˜¯å“ªä½ç©å®¶çš„ç‰Œçµ„
        let currentSpeakerId = null;
        let currentUtterance = null; 

        // æ’²å…‹ç‰Œæ’åºå’ŒèªéŸ³è½‰æ›æ˜ å°„
        const rankText = { 'A': 'Ace', 'J': 'Jack', 'Q': 'Queen', 'K': 'King', '10': 'å' }; 

        /**
         * åœæ­¢æ‰€æœ‰èªéŸ³æ’­æ”¾ï¼Œä¸¦é‡ç½®ç‹€æ…‹ã€‚
         */
        function stopSpeaking() {
            if ('speechSynthesis' in window) {
                window.speechSynthesis.cancel();
            }
            currentSpeakerId = null;
            currentUtterance = null;
            if (typeof renderUI === 'function') {
                renderUI();
            }
        }

        /**
         * æº–å‚™èªéŸ³å…§å®¹ä¸¦å•Ÿå‹•å¾ªç’°æ’­æ”¾
         */
        function startSpeakingLoop(cards, revealedNumbers, playerId) {
            if (!('speechSynthesis' in window)) {
                console.warn('Web Speech API ä¸è¢«æ”¯æ´ã€‚');
                return;
            }

            stopSpeaking(); 

            // 1. ç¯©é¸å‡ºæœªè¢«åŠƒæ‰çš„ç‰Œçš„ Rankï¼Œä¸¦å»é‡ã€æ’åº
            const unmarkedRanks = new Set();
            cards.forEach(card => {
                const rank = getCardRank(card);
                if (!revealedNumbers.includes(rank)) {
                    unmarkedRanks.add(rank);
                }
            });

            const uniqueRanksArray = Array.from(unmarkedRanks);
            const rankOrder = { 'A': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9, '10': 10, 'J': 11, 'Q': 12, 'K': 13 };
            const sortedRanks = uniqueRanksArray.sort((a, b) => rankOrder[a] - rankOrder[b]);

            // 2. è½‰æ›ç‚ºæœ—è®€æ–‡æœ¬
            const speakableList = sortedRanks
                .map(rank => rankText[rank] || rank)
                .join(', ');
                
            const textToSpeak = sortedRanks.length > 0 ? 
                `å‰©é¤˜çš„ç‰Œæœ‰ï¼š${speakableList}` : 
                'æ­å–œï¼ç‰Œå·²å…¨æ•¸æ¶ˆé™¤ã€‚';

            // 3. è¨­å®šå…¨åŸŸç‹€æ…‹
            currentSpeakerId = playerId;

            // 4. å•Ÿå‹•éè¿´æ’­æ”¾å¾ªç’°
            function recursiveSpeak() {
                if (currentSpeakerId !== playerId) return; 

                currentUtterance = new SpeechSynthesisUtterance(textToSpeak);
                currentUtterance.lang = 'zh-TW';
                currentUtterance.rate = 1.2;

                // èªéŸ³æ’­å ±çµæŸæ™‚ï¼Œä½¿ç”¨ setTimeout å»¶é² 3 ç§’å¾Œå†å‘¼å«è‡ªå·±ï¼Œå¯¦ç¾å¾ªç’°
                currentUtterance.onend = function() {
                    if (currentSpeakerId === playerId) {
                        
                        setTimeout(function() {
                            // åœ¨å»¶é²çµæŸå¾Œï¼Œå†æ¬¡ç¢ºèªç‹€æ…‹æ˜¯å¦ä»åœ¨æ’­æ”¾ä¸­
                            if (currentSpeakerId === playerId) {
                                recursiveSpeak();
                            }
                        }, 3000); // 3000 æ¯«ç§’ = 3 ç§’çš„é–“éš”

                    }
                };

                window.speechSynthesis.speak(currentUtterance);
            }
            
            recursiveSpeak();
            renderUI(); 
        }

        // ---------- Render UI ----------
        function renderUI() {
            if (!gameState) { joinPanel.classList.remove('hidden'); roomPanel.classList.add('hidden'); myNickEl.textContent = 'â€”'; updateMarquee(); return; }
            const players = gameState.players || {}; const cleanPlayers = {}; Object.keys(players).forEach(k => { if (players[k] && players[k].id) cleanPlayers[k] = players[k]; });
            const amInRoom = currentUser && cleanPlayers[currentUser.uid];
            
            // å¦‚æœèªéŸ³æ­£åœ¨æ’­æ”¾ï¼Œä¸”ç•¶å‰ç”¨æˆ¶å·²é€€å‡ºæˆ¿é–“ï¼Œå‰‡åœæ­¢èªéŸ³
            if (currentSpeakerId && !amInRoom) {
                stopSpeaking();
            }

            if (!amInRoom) { joinPanel.classList.remove('hidden'); roomPanel.classList.add('hidden'); roomOwnerEl.textContent = cleanPlayers[gameState.creatorId]?.nickname || 'â€”'; roomCountEl.textContent = `${Object.keys(cleanPlayers).length} / ${MAX_PLAYERS}`; updateMarquee(); return; }
            joinPanel.classList.add('hidden'); roomPanel.classList.remove('hidden'); myNickname = cleanPlayers[currentUser.uid].nickname || myNickname; myNickEl.textContent = myNickname;
            roomOwnerEl.textContent = cleanPlayers[gameState.creatorId]?.nickname || 'â€”'; roomCountEl.textContent = `${Object.keys(cleanPlayers).length} / ${MAX_PLAYERS}`; noticeEl.textContent = gameState.notice || '';

            const amHost = gameState.creatorId === currentUser.uid && myNickname === 'Kai';
            if (amHost) { btnStart.classList.remove('hidden'); btnRestart.classList.remove('hidden'); } else { btnStart.classList.add('hidden'); btnRestart.classList.add('hidden'); }

            renderBallButtons();
            updateMarquee();

            const revealedNumbers = gameState.revealedNumbers || [];
            const deckLen = (gameState.deck || []).length;

            playersArea.innerHTML = '';
            const pList = Object.values(cleanPlayers);

            pList.forEach(p => { p.unmarkedCount = calculateUnmarkedCards(p.cards || [], revealedNumbers); });

            pList.sort((a, b) => {
                if (a.id === currentUser.uid) return -1;
                if (b.id === currentUser.uid) return 1;
                if (a.unmarkedCount !== b.unmarkedCount) { return a.unmarkedCount - b.unmarkedCount; }
                if (a.id < b.id) return -1;
                if (a.id > b.id) return 1;
                return 0;
            });

            // ã€æ­¥é©Ÿ 3ï¼šæ¸²æŸ“ç©å®¶å€å¡Šã€‘
            pList.forEach(p => {
                const wrapper = document.createElement('div'); wrapper.className = 'p-3 rounded bg-slate-800 border border-slate-700';
                const header = document.createElement('div'); header.className = 'player-header mb-2';
                const left = document.createElement('div'); left.innerHTML = `<strong>${p.nickname || ('p_' + p.id.slice(0, 6))}</strong> ${p.id === currentUser.uid ? '<span class="small"> (æ‚¨)</span>' : ''}`;
                const right = document.createElement('div'); right.style.display = 'flex'; right.style.gap = '8px'; right.style.alignItems = 'center';

                const cards = p.cards || [];
                const totalCards = cards.length;
                const unmarkedCards = p.unmarkedCount;
                const isMyPlayer = currentUser && currentUser.uid === p.id; // <--- æ–°å¢æ­¤åˆ¤æ–·

                const countSpan = document.createElement('div'); countSpan.className = 'small';
                countSpan.textContent = `å‰©é¤˜ç‰Œ ${unmarkedCards} / ç¸½ç‰Œæ•¸ ${totalCards}`;

                // --- èªéŸ³æ’­æ”¾æŒ‰éˆ•é‚è¼¯ (é‡é»ä¿®æ”¹å€) ---
                const speakerBtn = document.createElement('button');
                const isPlayerSpeaking = currentSpeakerId === p.id;
                
                speakerBtn.textContent = isPlayerSpeaking ? 'â—¼ åœæ­¢' : 'ğŸ”Š æ’­æ”¾';
                
                if (isMyPlayer) {
                    // è‡ªå·±çš„ç‰Œçµ„ï¼šå•Ÿç”¨æ’­æ”¾/åœæ­¢åŠŸèƒ½
                    speakerBtn.className = isPlayerSpeaking ? 'speaker-btn stop' : 'speaker-btn play'; 
                    const cardsToSpeak = p.cards || [];
                    speakerBtn.onclick = () => {
                        if (isPlayerSpeaking) {
                            stopSpeaking();
                        } else {
                            startSpeakingLoop(cardsToSpeak, revealedNumbers, p.id); 
                        }
                    };
                } else {
                    // åˆ¥äººçš„ç‰Œçµ„ï¼šé–å®šæŒ‰éˆ•
                    speakerBtn.disabled = true;
                    speakerBtn.textContent = 'ğŸ”’ æ’­æ”¾';
                    // ç§»é™¤ active æ¨£å¼ï¼Œç¢ºä¿é¡¯ç¤ºç‚ºé–å®šæ¨£å¼
                    speakerBtn.classList.remove('play');
                    speakerBtn.classList.remove('stop');
                }
                // --- èªéŸ³æ’­æ”¾æŒ‰éˆ•é‚è¼¯ (çµæŸ) ---
                
                // --- çŠ¯è¦æŒ‰éˆ•é‚è¼¯ ---
                const foulBtn = document.createElement('button');
                foulBtn.className = 'foul-btn';
                foulBtn.textContent = 'çŠ¯è¦ +1';
                
                const canDraw = isMyPlayer && deckLen > 0;

                foulBtn.disabled = !canDraw;
                foulBtn.onclick = () => {
                    if (canDraw) foulDrawFor(p.id);
                };

                // é™„åŠ æŒ‰éˆ•: å‰©é¤˜ç‰Œæ•¸ -> æ’­æ”¾/åœæ­¢ -> çŠ¯è¦
                right.appendChild(countSpan); 
                right.appendChild(speakerBtn); 
                right.appendChild(foulBtn); 
                
                header.appendChild(left); header.appendChild(right); wrapper.appendChild(header);

                const cardsRow = document.createElement('div'); cardsRow.className = 'flex gap-2 flex-wrap';

                cards.forEach(c => {
                    const cardEl = document.createElement('div'); cardEl.className = 'card';
                    
                    const rank = getCardRank(c);
                    const isMarkedByBall = revealedNumbers.includes(rank);

                    if (isMarkedByBall) cardEl.classList.add('marked');
                    if (isMyPlayer) cardEl.classList.add('my-card'); // ä½¿ç”¨ isMyPlayer

                    const shouldShowFace = isMyPlayer || isMarkedByBall; // ä½¿ç”¨ isMyPlayer

                    if (shouldShowFace) {
                        cardEl.classList.add('card-face');
                        cardEl.textContent = c;
                        if (c[0] === 'â™¥' || c[0] === 'â™¦') cardEl.classList.add('suit-red');
                        else cardEl.classList.add('suit-black');
                        if (!isMyPlayer && isMarkedByBall) { cardEl.style.cursor = 'default'; }
                    } else {
                        cardEl.classList.add('card-back');
                        cardEl.textContent = '';
                    }

                    cardsRow.appendChild(cardEl);
                });
                wrapper.appendChild(cardsRow); playersArea.appendChild(wrapper);
            });
        }

        (async function () { await doAnonymousAuth(); })();
    </script>
</body>

</html>
