<!doctype html>
<html lang="zh-TW">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Pool Poker — Single Room</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    body { background:#0f172a; color:#e6eef8; font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; }
    .card { width:48px; height:64px; border-radius:8px; display:flex;align-items:center;justify-content:center;font-weight:700;box-shadow:0 4px 12px rgba(2,6,23,.6); }
    .card-back { background:linear-gradient(180deg,#0b1220,#091026); border:2px solid rgba(255,255,255,.04); color:transparent; }
    .card-face { background:white; color:#0b1220; border:2px solid rgba(2,6,23,.06); }
    .marked { outline:3px solid #f59e0b; transform:scale(1.05); }
    .small { font-size:.85rem; color:#cfe8ff; }
  </style>
</head>
<body>
  <div class="max-w-4xl mx-auto p-6">
    <h1 class="text-2xl font-bold mb-4">Pool Poker — 單一房間 (main_room)</h1>

    <div id="status" class="mb-4 text-sm small">初始化中…（請開 Console 查看詳細）</div>

    <div id="controls" class="mb-6 grid grid-cols-1 sm:grid-cols-3 gap-3">
      <div class="col-span-2">
        <label class="small">您的暱稱（房主固定為 <strong>kai</strong>）</label>
        <input id="nickname" class="w-full p-2 rounded bg-slate-800 border border-slate-700" placeholder="輸入暱稱（若您是房主會自動成為 kai）" />
      </div>
      <div>
        <button id="btnJoin" class="w-full py-2 rounded bg-emerald-600 hover:bg-emerald-500">加入房間</button>
        <button id="btnLeave" class="w-full py-2 rounded mt-2 bg-slate-700 hidden">離開房間</button>
      </div>
    </div>

    <div id="roomInfo" class="mb-4 p-4 rounded bg-slate-800 border border-slate-700 hidden">
      <div class="flex items-center justify-between mb-2">
        <div>
          <div class="text-xs small">房間 ID</div>
          <div id="roomId" class="font-mono">main_room</div>
        </div>
        <div>
          <div class="text-xs small">房主</div>
          <div id="roomOwner" class="font-bold">—</div>
        </div>
        <div>
          <div class="text-xs small">人數</div>
          <div id="roomCount">0 / 5</div>
        </div>
      </div>

      <div class="flex gap-2 items-center mb-3">
        <button id="btnStart" class="px-3 py-2 rounded bg-yellow-600 hover:bg-yellow-500 hidden">發牌（房主）</button>
        <button id="btnRestart" class="px-3 py-2 rounded bg-slate-700 hover:bg-slate-600 hidden">重開（房主）</button>
        <div id="notice" class="ml-4 small text-slate-300"></div>
      </div>

      <div class="grid grid-cols-1 md:grid-cols-2 gap-4" id="playersArea"></div>
    </div>

    <div id="debug" class="mt-6 p-3 rounded bg-slate-900 border border-slate-700 text-xs small">
      <div><strong>Debug Console (只會顯示少量資訊)</strong></div>
      <pre id="log" class="text-xs mt-2"></pre>
    </div>
  </div>

  <script type="module">
    // Firebase v11 modules
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
    import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
    import { getFirestore, doc, onSnapshot, setDoc, updateDoc, getDoc, arrayUnion, serverTimestamp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

    // -----------------------------
    // CONFIG (請按需修改；預設使用你給的值)
    const EXTERNAL_FIREBASE_CONFIG = {
      apiKey: "AIzaSyCk54DEp6rzvpfQBBNW_iJByZ3boyHEPF0",
      authDomain: "poolpokergame-b88ed.firebaseapp.com",
      projectId: "poolpokergame-b88ed",
      // 按你的要求保留此值
      storageBucket: "poolpokergame-b88ed.firebasestorage.app",
      messagingSenderId: "574863840102",
      appId: "1:574863840102:web:14368aaf84b3640c6eeea7"
    };
    // -----------------------------

    // Firestore path for the single room
    const APP_ID = EXTERNAL_FIREBASE_CONFIG.projectId;
    const ROOM_DOC_PATH = `artifacts/${APP_ID}/public/data/pool_poker_rooms/main_room`;
    const MAX_PLAYERS = 5;
    const CARDS_PER_PLAYER = 8;

    // UI elements
    const statusEl = document.getElementById('status');
    const logEl = document.getElementById('log');
    const nicknameInput = document.getElementById('nickname');
    const btnJoin = document.getElementById('btnJoin');
    const btnLeave = document.getElementById('btnLeave');
    const roomInfoEl = document.getElementById('roomInfo');
    const roomOwnerEl = document.getElementById('roomOwner');
    const roomCountEl = document.getElementById('roomCount');
    const playersArea = document.getElementById('playersArea');
    const roomIdEl = document.getElementById('roomId');
    const noticeEl = document.getElementById('notice');
    const btnStart = document.getElementById('btnStart');
    const btnRestart = document.getElementById('btnRestart');

    // init firebase
    const app = initializeApp(EXTERNAL_FIREBASE_CONFIG);
    const auth = getAuth(app);
    const db = getFirestore(app);
    const roomDocRef = doc(db, ROOM_DOC_PATH);

    // local state
    let currentUser = null;
    let gameState = null;
    let isJoined = false;

    // small helper logs
    function log(...args) {
      console.log(...args);
      logEl.textContent += args.map(a=> (typeof a==='object' ? JSON.stringify(a) : String(a))).join(' ') + "\\n";
      logEl.scrollTop = logEl.scrollHeight;
    }
    function setStatus(s) { statusEl.textContent = s; }

    // ---------- Auth ----------
    async function doAuth() {
      setStatus('正在登入 Firebase (匿名)...');
      try {
        const cred = await signInAnonymously(auth);
        log('Signed in anonymously uid=', cred.user.uid);
      } catch (e) {
        log('Auth failed', e);
        setStatus('Auth 失敗，請檢查 Firebase Console（需啟用匿名登入）');
      }
    }

    onAuthStateChanged(auth, async (user) => {
      if (!user) {
        currentUser = null;
        setStatus('未登入');
        return;
      }
      currentUser = user;
      setStatus('已登入：' + currentUser.uid);
      log('onAuthStateChanged', currentUser.uid);
      // auto-subscribe to room document
      subscribeRoom();
    });

    // ---------- Room subscription ----------
    let unsubscribeRoom = null;
    function subscribeRoom() {
      if (unsubscribeRoom) return;
      setStatus('訂閱房間資料...');
      unsubscribeRoom = onSnapshot(roomDocRef, (snap) => {
        if (snap.exists()) {
          gameState = snap.data();
          renderRoom();
          setStatus('已連線到房間');
        } else {
          gameState = null;
          renderRoom();
          setStatus('房間尚未建立（尚無人）');
        }
      }, (err) => {
        log('Snapshot error', err);
        setStatus('無法訂閱房間：' + (err.message || err));
      });
    }

    // ---------- UI actions ----------
    btnJoin.addEventListener('click', async () => {
      if (!currentUser) { setStatus('尚未登入'); return; }
      // If room not exists, we'll create it with this user as creator and nickname 'kai'
      const desiredNick = (nicknameInput.value || '').trim();
      try {
        const snap = await getDoc(roomDocRef);
        if (!snap.exists()) {
          // create room and set this user as creator (房主暱稱固定 kai)
          const players = {};
          players[currentUser.uid] = { id: currentUser.uid, nickname: 'kai', cards: [], marked: [] };
          await setDoc(roomDocRef, {
            creatorId: currentUser.uid,
            players,
            gameStarted: false,
            notice: '房間建立，房主為 kai',
            updatedAt: serverTimestamp()
          });
          isJoined = true;
          btnLeave.classList.remove('hidden');
          nicknameInput.value = ''; // owner fixed to kai
          setStatus('已建立房間並以 kai 身份加入（您為房主）');
          log('Room created by', currentUser.uid);
          return;
        } else {
          // room exists: join as a normal player
          const data = snap.data();
          const players = data.players || {};
          if (players[currentUser.uid]) {
            setStatus('您已在房間中');
            isJoined = true;
            btnLeave.classList.remove('hidden');
            return;
          }
          const count = Object.keys(players).length;
          if (count >= MAX_PLAYERS) {
            setStatus('房間已滿，無法加入');
            return;
          }
          // choose nickname: provided or fallback to uid short
          const nick = desiredNick || ('p_' + currentUser.uid.slice(0,6));
          // use field-path update to avoid overwriting entire players object
          await updateDoc(roomDocRef, {
            [`players.${currentUser.uid}`]: {
              id: currentUser.uid,
              nickname: nick,
              cards: [],
              marked: []
            },
            updatedAt: serverTimestamp()
          });
          isJoined = true;
          btnLeave.classList.remove('hidden');
          setStatus('已加入房間');
          log('Joined as', nick);
        }
      } catch (e) {
        log('Join error', e);
        setStatus('加入失敗：' + (e.message || e));
      }
    });

    btnLeave.addEventListener('click', async () => {
      if (!currentUser) return;
      try {
        // remove our player entry
        // Firestore does not have a direct delete of map field via updateDoc except using deleteField
        // but to keep simple (功能優先)，我們 set players.<uid> to null (or {}) — better to use update with deleteField
        // here we'll set to null then let rule/cleanup handle it; but to avoid the need, we will use updateDoc with deleteField
        // however deleteField must be imported; for simplicity we'll overwrite with {}
        await updateDoc(roomDocRef, {
          [`players.${currentUser.uid}`]: null,
          updatedAt: serverTimestamp()
        });
        isJoined = false;
        btnLeave.classList.add('hidden');
        setStatus('已離開房間');
      } catch (e) {
        log('Leave failed', e);
        setStatus('離開失敗：' + (e.message || e));
      }
    });

    btnStart.addEventListener('click', async () => {
      if (!currentUser || !gameState) return;
      if (gameState.creatorId !== currentUser.uid) {
        setStatus('僅房主可發牌');
        return;
      }
      // ensure there is at least 1 player
      const players = gameState.players || {};
      const pids = Object.keys(players);
      if (pids.length === 0) {
        setStatus('沒有玩家');
        return;
      }
      if (pids.length > MAX_PLAYERS) {
        setStatus('人數超過上限');
        return;
      }
      try {
        // build real 52-card deck (1..13 each 4)
        let deck = [];
        for (let r=1;r<=13;r++){
          for (let k=0;k<4;k++) deck.push(r);
        }
        // shuffle
        for (let i = deck.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [deck[i], deck[j]] = [deck[j], deck[i]];
        }
        // deal CARDS_PER_PLAYER to each player in order of pids
        const newPlayers = {};
        pids.forEach((pid, idx) => {
          const start = idx * CARDS_PER_PLAYER;
          const hand = deck.slice(start, start + CARDS_PER_PLAYER);
          newPlayers[pid] = {
            ...players[pid],
            cards: hand,
            marked: []
          };
        });
        // write back: set players.* for each player (using field paths to minimize overwrite)
        const updateObj = { gameStarted: true, notice: '遊戲開始：已發牌', updatedAt: serverTimestamp() };
        pids.forEach(pid => {
          updateObj[`players.${pid}.cards`] = newPlayers[pid].cards;
          updateObj[`players.${pid}.marked`] = [];
        });
        await updateDoc(roomDocRef, updateObj);
        setStatus('發牌完畢');
      } catch (e) {
        log('Start error', e);
        setStatus('發牌失敗：' + (e.message || e));
      }
    });

    btnRestart.addEventListener('click', async () => {
      if (!currentUser || !gameState) return;
      if (gameState.creatorId !== currentUser.uid) {
        setStatus('僅房主可重開');
        return;
      }
      try {
        // reset cards to empty and gameStarted -> false
        const players = gameState.players || {};
        const updateObj = { gameStarted: false, notice: '房主已重開', updatedAt: serverTimestamp() };
        Object.keys(players).forEach(pid => {
          updateObj[`players.${pid}.cards`] = [];
          updateObj[`players.${pid}.marked`] = [];
        });
        await updateDoc(roomDocRef, updateObj);
        setStatus('已重開');
      } catch (e) {
        log('Restart error', e);
        setStatus('重開失敗：' + (e.message || e));
      }
    });

    // clicking a card -> mark number (only allowed when gameStarted)
    async function markCard(playerId, cardValue) {
      if (!currentUser || !gameState) return;
      if (!gameState.gameStarted) {
        setStatus('遊戲尚未開始');
        return;
      }
      // only your own marked array should be updated by you
      if (playerId !== currentUser.uid) {
        setStatus('只能標記自己的卡');
        return;
      }
      const myData = (gameState.players || {})[currentUser.uid];
      if (!myData) return;
      if ((myData.marked || []).includes(cardValue)) {
        setStatus('已標記過');
        return;
      }
      try {
        // append to marked via direct set of array (functionality first) — could use arrayUnion but we didn't import it to keep things tight
        const newMarked = [...(myData.marked || []), cardValue];
        await updateDoc(roomDocRef, {
          [`players.${currentUser.uid}.marked`]: newMarked,
          notice: `${myData.nickname || '玩家'} 標記了 ${cardValue}`,
          updatedAt: serverTimestamp()
        });
        setStatus('已標記 ' + cardValue);
      } catch (e) {
        log('Mark error', e);
        setStatus('標記失敗：' + (e.message || e));
      }
    }

    // ---------- Render ----------
    function renderRoom() {
      // show/hide room info
      if (!gameState) {
        roomInfoEl.classList.add('hidden');
        btnStart.classList.add('hidden');
        btnRestart.classList.add('hidden');
        roomIdEl.textContent = 'main_room';
        roomOwnerEl.textContent = '—';
        roomCountEl.textContent = '0 / ' + MAX_PLAYERS;
        playersArea.innerHTML = '';
        noticeEl.textContent = '';
        return;
      }
      roomInfoEl.classList.remove('hidden');
      roomIdEl.textContent = 'main_room';
      roomOwnerEl.textContent = (gameState.players && Object.values(gameState.players).find(p => p.id === gameState.creatorId)?.nickname) || 'kai';
      const players = gameState.players || {};
      const cleanPlayers = {};
      // remove null entries (we used null for leave)
      Object.keys(players).forEach(k => {
        if (players[k] && typeof players[k] === 'object' && players[k].id) cleanPlayers[k] = players[k];
      });
      const count = Object.keys(cleanPlayers).length;
      roomCountEl.textContent = `${count} / ${MAX_PLAYERS}`;
      noticeEl.textContent = gameState.notice || '';
      // owner controls
      const amOwner = currentUser && gameState.creatorId === currentUser.uid;
      if (amOwner) {
        btnStart.classList.remove('hidden');
        btnRestart.classList.remove('hidden');
      } else {
        btnStart.classList.add('hidden');
        btnRestart.classList.add('hidden');
      }

      // build playersArea
      playersArea.innerHTML = '';
      // order: current user first if present, then others
      const pList = Object.values(cleanPlayers);
      pList.sort((a,b)=> (a.id===currentUser?.uid ? -1 : (b.id===currentUser?.uid ? 1 : 0)));
      pList.forEach(p => {
        const cardContainer = document.createElement('div');
        cardContainer.className = 'p-3 rounded bg-slate-900 border border-slate-700';

        const title = document.createElement('div');
        title.className = 'flex justify-between items-center mb-2';
        title.innerHTML = `<div><strong>${p.nickname || ('p_' + p.id.slice(0,6))}</strong> ${p.id===currentUser?.uid?'<span class="small"> (您)</span>':''}</div>
                           <div class="small">擊落 ${ (p.marked||[]).length } / ${CARDS_PER_PLAYER}</div>`;
        cardContainer.appendChild(title);

        const cardsRow = document.createElement('div');
        cardsRow.className = 'flex gap-2 flex-wrap';

        const cards = p.cards || [];
        if (cards.length === 0) {
          const hint = document.createElement('div');
          hint.className = 'small text-slate-400';
          hint.textContent = gameState.gameStarted ? '尚未發到牌' : '等待遊戲開始';
          cardContainer.appendChild(hint);
        }
        cards.forEach((c,i)=>{
          const cardEl = document.createElement('div');
          cardEl.className = 'card';
          const isMine = currentUser && p.id === currentUser.uid;
          const isMarked = (p.marked || []).includes(c);
          if (isMarked) cardEl.classList.add('marked');
          if (isMine) {
            cardEl.classList.add('card-face');
            cardEl.textContent = c;
            cardEl.style.cursor = 'pointer';
            cardEl.title = isMarked ? '已標記' : '點擊以標記';
            cardEl.onclick = () => markCard(p.id, c);
          } else {
            // other player's view: show back except if marked (we show value when marked)
            if (isMarked) {
              cardEl.classList.add('card-face');
              cardEl.textContent = c;
            } else {
              cardEl.classList.add('card-back');
              cardEl.textContent = ' ';
            }
          }
          cardsRow.appendChild(cardEl);
        });

        cardContainer.appendChild(cardsRow);
        playersArea.appendChild(cardContainer);
      });

      // show join/leave buttons appropriately
      if (currentUser && Object.keys(cleanPlayers).some(p=>p.id === currentUser.uid)) {
        btnJoin.classList.add('hidden');
        btnLeave.classList.remove('hidden');
      } else {
        btnJoin.classList.remove('hidden');
        btnLeave.classList.add('hidden');
      }
    }

    // ---------- startup ----------
    (async function() {
      await doAuth();
      // subscribeRoom() will be triggered by auth state change handler
    })();

  </script>
</body>
</html>



